---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ meta.name }}-mirror-maker
  namespace: {{ meta.namespace }}
data:
  consumer.config: |
    allow.auto.create.topics={{ consumer.allow_auto_create_topics }}
    auto.commit.interval.ms={{ consumer.auto_commit_interval_ms }}
    auto.offset.reset={{ consumer.auto_offset_reset }}
    bootstrap.servers={{ consumer.bootstrap_servers }}
    check.crcs={{ consumer.check_crcs }}
    client.dns.lookup={{ consumer.client_dns_lookup }}
    #client.id=
    client.rack={{ consumer.client_rack }}
    connections.max.idle.ms={{ consumer.connections_max_idle_ms }}
    default.api.timeout.ms={{ consumer.default_api_timeout_ms }}
    enable.auto.commit={{ consumer.enable_auto_commit }}
    exclude.internal.topics={{ consumer.exclude_internal_topics }}
    fetch.max.bytes={{ consumer.fetch_max_bytes }}
    fetch.max.wait.ms={{ consumer.fetch_max_wait_ms }}
    fetch.min.bytes={{ consumer.fetch_min_bytes }}
    group.id={{ consumer.group_id }}
    #group.instance.id={{ consumer.group_instance_id }}
    heartbeat.interval.ms={{ consumer.heartbeat_interval_ms }}
    interceptor.classes={{ consumer.interceptor_classes }}
    isolation.level={{ consumer.isolation_level }}
    max.partition.fetch.bytes={{ consumer.max_partition_fetch_bytes }}
    max.poll.interval.ms={{ consumer.max_poll_interval_ms }}
    max.poll.records={{ consumer.max_poll_records }}
    #metadata.max.age.ms={{ consumer.metadata_max_age_ms }}
    #metric.reporters={{ consumer.metric_reporters }}
    metrics.num.samples={{ consumer.metrics_num_samples }}
    metrics.recording.level={{ consumer.metrics_recording_level }}
    metrics.sample.window.ms={{ consumer.metrics_sample_window_ms }}
    partition.assignment.strategy={{ consumer.partition_assignment_strategy }}
    receive.buffer.bytes={{ consumer.receive_buffer_bytes }}
    reconnect.backoff.max.ms={{ consumer.reconnect_backoff_max_ms }}
    reconnect.backoff.ms={{ consumer.reconnect_backoff_ms }}
    retry.backoff.ms={{ consumer.retry_backoff_ms }}
    request.timeout.ms={{ consumer.request_timeout_ms }}
    #sasl.client.callback.handler.class={{ consumer.sasl_client_callback_handler_class }}
    #sasl.jaas.config={{ consumer.sasl_jaas_config }}
    sasl.kerberos.kinit.cmd={{ consumer.sasl_kerberos_kinit_cmd }}
    sasl.kerberos.min.time.before.relogin={{ consumer.sasl_kerberos_min_time_before_relogin }}
    sasl.kerberos.service.name={{ consumer.sasl_kerberos_service_name }}
    sasl.kerberos.ticket.renew.jitter={{ consumer.sasl_kerberos_ticket_renew_jitter }}
    sasl.kerberos.ticket.renew.window.factor={{ consumer.sasl_kerberos_ticket_renew_window_factor }}
    #sasl.login.callback.handler.class={{ consumer.sasl_login_callback_handler_class }}
    #sasl.login.class={{ consumer.sasl_login_class }}
    #sasl.login.refresh.buffer.seconds={{ consumer.sasl_login_refresh_buffer_seconds }}
    sasl.login.refresh.min.period.seconds={{ consumer.sasl_login_refresh_min_period_seconds }}
    sasl.login.refresh.window.factor={{ consumer.sasl_login_refresh_window_factor }}
    sasl.login.refresh.window.jitter={{ consumer.sasl_login_refresh_window_jitter }}
    #sasl.mechanism={{ consumer.sasl_mechanism }}
    security.protocol={{ consumer.security_protocol }}
    #security.providers={{ consumer.security_provider }}
    send.buffer.bytes={{ consumer.send_buffer_bytes }}
    session.timeout.ms={{ consumer.session_timeout_ms }}
    #ssl.cipher.suites={{ consumer.ssl_cipher_suites }}
    ssl.enabled.protocols={{ consumer.ssl_enabled_protocols }}
    ssl.endpoint.identification.algorithm={{ consumer.ssl_endpoint_identification_algorithm }}
    ssl.keymanager.algorithm={{ consumer.ssl_keymanager_algorithm }}
    ssl.key.password={{ consumer.ssl_key_password }}
    #ssl.keystore.location={{ consumer.ssl_keystore_location }}
    #ssl.keystore.password={{ consumer.ssl_keystore_password }}
    ssl.keystore.type={{ consumer.ssl_keystore_type }}
    ssl.protocol={{ consumer.ssl_protocol }}
    #ssl.provider={{ consumer.ssl_provider }}
    ssl.secure.random.implementation={{ consumer.ssl_secure_random_implementation }}
    ssl.trustmanager.algorithm={{ consumer.ssl_trustmanager_algorithm }}
    #ssl.truststore.location={{ consumer.ssl_truststore_location }}
    #ssl.truststore.password={{ consumer.ssl_truststore_password }}
    ssl.truststore.type={{ consumer.ssl_truststore_type }}
  producer.config: |
    acks={{ producer.acks }}
    batch.size={{ producer.batch_size }}
    bootstrap.servers={{ producer.bootstrap_servers }}
    buffer.memory={{ producer.buffer_memory }}
    client.dns.lookup={{ producer.client_dns_lookup }}
    #client.id=
    compression.type={{ producer.compression_type }}
    connections.max.idle.ms={{ producer.connections_max_idle_ms }}
    delivery.timeout.ms={{ producer.delivery_timeout_ms }}
    enable.idempotence={{ producer.enable_idempotence }}
    #interceptor.classes=
    #key.serializer=
    linger.ms={{ producer.linger_ms }}
    max.block.ms={{ producer.max_block_ms }}
    max.in.flight.requests.per.connection={{ producer.max_in_flight_requests_per_connection }}
    max.request.size={{ producer.max_request_size }}
    metadata.max.age.ms={{ producer.metadata_max_age_ms }}
    metadata.max.idle.ms={{ producer.metadata_max_idle_ms }}
    #metric.reporters=
    metrics.num.samples={{ producer.metrics_num_samples }}
    metrics.recording.level={{ producer.metrics_recording_level }}
    metrics.sample.window.ms={{ producer.metrics_sample_window_ms }}
    #partitioner.class=
    receive.buffer.bytes={{ producer.receive_buffer_bytes }}
    reconnect.backoff.max.ms={{ producer.reconnect_backoff_max_ms }}
    reconnect.backoff.ms={{ producer.reconnect_backoff_ms }}
    retries={{ producer.retries }}
    retry.backoff.ms={{ producer.retry_backoff_ms }}
    request.timeout.ms={{ producer.request_timeout_ms }}
    #sasl.client.callback.handler.class=
    #sasl.jaas.config=
    sasl.kerberos.kinit.cmd={{ producer.sasl_kerberos_kinit_cmd }}
    sasl.kerberos.min.time.before.relogin={{ producer.sasl_kerberos_min_time_before_relogin }}
    #sasl.kerberos.service.name=
    sasl.kerberos.ticket.renew.jitter={{ producer.sasl_kerberos_ticket_renew_jitter }}
    sasl.kerberos.ticket.renew.window.factor={{ producer.sasl_kerberos_ticket_renew_window_factor }}
    #sasl.login.callback.handler.class=
    #sasl.login.class=
    sasl.login.refresh.buffer.seconds={{ producer.sasl_login_refresh_buffer_seconds }}
    sasl.login.refresh.min.period.seconds={{ producer.sasl_login_refresh_min_period_seconds }}
    sasl.login.refresh.window.factor={{ producer.sasl_login_refresh_window_factor }}
    sasl.login.refresh.window.jitter={{ producer.sasl_login_refresh_window_jitter }}
    #sasl.mechanism=
    security.protocol={{ producer.security_protocol }}
    #security.providers=
    send.buffer.bytes={{ producer.send_buffer_bytes }}
    #ssl.cipher.suites=
    ssl.enabled.protocols={{ producer.ssl_enabled_protocols }}
    ssl.endpoint.identification.algorithm={{ producer.ssl_endpoint_identification_algorithm }}
    #ssl.key.password=
    ssl.keymanager.algorithm={{ producer.ssl_keymanager_algorithm }}
    #ssl.keystore.location=
    #ssl.keystore.password=
    ssl.keystore.type={{ producer.ssl_keystore_type }}
    ssl.protocol={{ producer.ssl_protocol }}
    #ssl.provider=
    #ssl.secure.random.implementation=
    ssl.trustmanager.algorithm={{ producer.ssl_trustmanager_algorithm }}
    #ssl.truststore.location=
    #ssl.truststore.password=
    #ssl.truststore.type=
    transaction.timeout.ms={{ producer.transaction_timeout_ms }}
    #transactional.id=
    #value.serializer=
  topics: {% for topic in topics %}{{ topic }}{% if not loop.last %}, {% endif %}{% endfor %}

---
